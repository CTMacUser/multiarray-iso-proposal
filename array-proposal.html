<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=us-ascii">
  <title>Proposal to Add Multi-Dimensional Support to std::array</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/">
</head>

<body>
<pre>Document number: Nnnnn=yy-nnnn
Project: Programming Language C++, Library Working Group
Date: 2013-09-10
Reply-to: Daryle Walker &lt;darylew at gmail dot com&gt;</pre>

<h1>Proposal to Add Multi-Dimensional Support to <code>std::array</code></h1>

<h2 name="Ch01">I. Table of Contents</h2>

<ol>
  <li><a href="Ch01">Table of Contents</a></li>
  <li><a href="Ch02">Introduction</a></li>
  <li><a href="Ch03">Motivation and Scope</a></li>
  <li><a href="Ch04">Impact on the Standard</a></li>
  <li><a href="Ch05">Design Decisions</a></li>
  <li><a href="Ch06">Technical Specifications</a></li>
  <li><a href="Ch07">Acknowlegdements</a></li>
  <li><a href="Ch08">References</a></li>
</ol>

<h2 name="Ch02">II. Introduction</h2>

<p>The <code>std::array</code> class template adapts array types to standard
library classes. But the adaptation is only for the outermost level; the inner
dimensions of a multidimensional array type are not considered. This proposal
is to change <code>std::array</code> to take multiple dimensions as variadic
template arguments.</p>

<h2 name="Ch03">III. Motivation and Scope</h2>

<p>When reading up on the variadic template feature, I made a multidimensional
variant of <code>std::array</code> as an exercise. After making the
single-extent case compatible with <code>std::array</code>, I realized that
this library is better as a change in <code>std::array</code> instead of
creating a near-identical class template. The exercise code, at &lt;<a
href="https://github.com/CTMacUser/ArrayMD">https://github.com/CTMacUser/ArrayMD</a>&gt;,
could be considered as a reference implementation and test suite.</p>

<p>I later found out that a multidimensional array class template was one of
the examples given in the original variadic template proposal.</p>

<p>A multidimensional array class template would provide a way to describe said
array types as a comma-separated list, whose consistency helps programmers of
all levels, since it will compatible with more language constructs than a group
of bracketed values. The class template can act as a transformation-trait
type.</p>

<h2 name="Ch04">IV. Impact on the Standard</h2>

<p>The proposal adds a class template, an type-alias template, and members to
an existing class template. It also modifies descriptions of
<code>std::array</code> in the sequence container requirements. The
implementation should work with current language features.</p>

<h2 name="Ch05">V. Design Decisions</h2>

<p>I adapted <code>std::array</code> for multidimensional arrays by making the
inner array object a built-in multidimensional array type. Since built-in types
are used, only the first level of access via <code>operator []()</code> can be
a function instead of a built-in operation. I've seen similar libraries that
nest <code>std::array</code> instantiations, which is longer to express and may
bloat the final object size due to padding.</p>

<p>The implementation is mostly as straight forward as the current
<code>std::array</code>, so there isn't much effort needed from
implementers.</p>

<h2 name="Ch06">VI. Technical Specifications</h2>

<p>The changes are based off C++ Working Draft Standard N3691. The section
numbers for new sections have letters as place-holders; the final numbers, plus
moving existing section numbers to fit, are to be determined later.</p>

<p>In section 20.11.2 [meta.type.synop], change the subsection introducing
array modifications:</p>

<blockquote>
  <p><i>// 20.11.7.4, array modifications:</i></p>
  <pre>template &lt;class T&gt; struct remove_extent;
template &lt;class T&gt; struct remove_all_extents;
<ins>template &lt;class T, unsigned I&gt; struct remove_some_extents;</ins>

template &lt;class T&gt;
  using remove_extent_t = typename remove_extent&lt;T&gt;::type;
template &lt;class T&gt;
  using remove_all_extents_t = typename remove_all_extents&lt;T&gt;::type;
<ins>template &lt;class T, unsigned I&gt;
  using remove_some_extents_t = typename remove_some_extents&lt;T, I&gt;::type;</ins></pre>
</blockquote>

<p>In section 20.11.7.4 [meta.trans.arr], add a third row to Table 55:</p>

<blockquote>

  <table border="1">
    <caption>Addition to: Table 55 &mdash; Array modifications</caption>
    <thead>
      <tr>
        <th>Template</th>
        <th>Comments</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><pre>template &lt;class T, unsigned I&gt;
struct remove_some_extents;</pre>
        </td>
        <td>If <code>I</code> is zero, then the member typedef
          <code>type</code> shall be <code>T</code>. Otherwise, the member
          typedef <code>type</code> shall be the same as applying
          <code>remove_extent</code> <code>I</code> times. [<em>Note:</em> When
          <code>T</code> is either a non-array type or an array type with an
          extent count at most <code>I</code>, this class template acts like
          <code>remove_all_extents</code>. <em>&mdash;end note</em>]</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p>and add a third example:</p>

<blockquote>
  <p><strong>-3-</strong> [<em>Example</em></p>

  <p><em>// the following assertions hold:</em></p>
  <pre>assert((is_same&lt;remove_some_extents&lt;int, 0&gt;::type, int&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int, 1&gt;::type, int&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[2], 0&gt;::type, int[2]&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[2], 1&gt;::type, int&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[2], 2&gt;::type, int&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[2][3], 0&gt;::type, int[2][3]&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[2][3], 1&gt;::type, int[3]&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[2][3], 2&gt;::type, int&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[][3], 0&gt;::type, int[][3]&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[][3], 1&gt;::type, int[3]&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[][3], 2&gt;::type, int&gt;::value));</pre>
  <pre>assert((is_same&lt;remove_some_extents&lt;int[][3], 3&gt;::type, int&gt;::value));</pre>

  <p><em>&mdash;end example</em>]</p>
</blockquote>

<p>In section 23.2.3 [sequence.reqmts], modify the last column for the last two
rows of Table 101:</p>

<blockquote>

  <table border="1">
    <caption>Modification to: Table 101 &mdash; Optional sequence container
    operations (continued)</caption>
    <thead>
      <tr>
        <th>Expression</th>
        <th>Return type</th>
        <th>Operational semantics</th>
        <th>Container</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>a[n]</code></td>
        <td><code>reference</code>; <code>const_reference</code> for constant
          <code>a</code></td>
        <td><code>*(a.begin() + n)</code></td>
        <td><code>basic_string</code>, <code>array</code> <ins>(with one
          extent)</ins>, <code>deque</code>, <code>dynarray</code>,
          <code>vector</code></td>
      </tr>
      <tr>
        <td><code>a.at(n)</code></td>
        <td><code>reference</code>; <code>const_reference</code> for constant
          <code>a</code></td>
        <td><code>*(a.begin() + n)</code></td>
        <td><code>basic_string</code>, <code>array</code> <ins>(with one
          extent)</ins>, <code>deque</code>, <code>dynarray</code>,
          <code>vector</code></td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p>and modify the following paragraph:</p>

<blockquote>
  <p><strong>-17-</strong> The member function <code>at()</code> provides
  bounds-checked access to container elements. <code>at()</code> throws
  <code>out_of_range</code> if <code>n &gt;= a.size()</code>. <ins>For
  instantiations of <code>array</code> with an extent count besides one, there
  are modifications (23.3.2.D) to the return type and the operational semantics
  of <code>a[n]</code> and <code>a.at()</code>.</ins> </p>
</blockquote>

<p>In section 23.3.1 [sequences.general], modify the "<strong>Header
<code>&lt;array&gt;</code> synopsis</strong>":</p>

<blockquote>
  <pre>#include &lt;initializer_list&gt;
<ins>#include &lt;type_traits&gt;</ins>

namespace std {
  template &lt;class T, size_t <ins>...</ins>N &gt; struct array;
  template &lt;class T, <ins>class U,</ins> size_t <ins>...</ins>N&gt;
    bool operator==(const array&lt;T,N<ins>...</ins>&gt;&amp; x, const array&lt;<del>T</del><ins>U</ins>,N<ins>...</ins>&gt;&amp; y);
  template &lt;class T, <ins>class U,</ins> size_t <ins>...</ins>N&gt;
    bool operator!=(const array&lt;T,N<ins>...</ins>&gt;&amp; x, const array&lt;<del>T</del><ins>U</ins>,N<ins>...</ins>&gt;&amp; y);
  template &lt;class T, <ins>class U,</ins> size_t <ins>...</ins>N&gt;
    bool operator&lt;(const array&lt;T,N<ins>...</ins>&gt;&amp; x, const array&lt;<del>T</del><ins>U</ins>,N<ins>...</ins>&gt;&amp; y);
  template &lt;class T, <ins>class U,</ins> size_t <ins>...</ins>N&gt;
    bool operator&gt;(const array&lt;T,N<ins>...</ins>&gt;&amp; x, const array&lt;<del>T</del><ins>U</ins>,N<ins>...</ins>&gt;&amp; y);
  template &lt;class T, <ins>class U,</ins> size_t <ins>...</ins>N&gt;
    bool operator&lt;=(const array&lt;T,N<ins>...</ins>&gt;&amp; x, const array&lt;<del>T</del><ins>U</ins>,N<ins>...</ins>&gt;&amp; y);
  template &lt;class T, <ins>class U,</ins> size_t <ins>...</ins>N&gt;
    bool operator&gt;=(const array&lt;T,N<ins>...</ins>&gt;&amp; x, const array&lt;<del>T</del><ins>U</ins>,N<ins>...</ins>&gt;&amp; y);
  template &lt;class T, size_t <ins>...</ins>N &gt;
    void swap(array&lt;T,N<ins>...</ins>&gt;&amp; x, array&lt;T,N<ins>...</ins>&gt;&amp; y) noexcept(noexcept(x.swap(y)));

  <ins>template &lt;class T, size_t ...N&gt;
    using array_t = typename array&lt;T, N...&gt;::type;</ins>

  template &lt;class T&gt; class tuple_size;
  template &lt;size_t I, class T&gt; class tuple_element;
  template &lt;class T, size_t <ins>...</ins>N&gt;
    struct tuple_size&lt;array&lt;T, N<ins>...</ins>&gt; &gt;;
  template &lt;size_t I, class T, size_t <ins>...</ins>N&gt;
    struct tuple_element&lt;I, array&lt;T, N<ins>...</ins>&gt; &gt;;
  template &lt;size_t I, class T, size_t <ins>...</ins>N&gt;
    constexpr T&amp; get(array&lt;T, N<ins>...</ins>&gt;&amp;) noexcept;
  template &lt;size_t I, class T, size_t <ins>...</ins>N&gt;
    constexpr T&amp;&amp; get(array&lt;T, N<ins>...</ins>&gt;&amp;&amp;) noexcept;
  template &lt;size_t I, class T, size_t <ins>...</ins>N&gt;
    constexpr const T&amp; get(const array&lt;T, N<ins>...</ins>&gt;&amp;) noexcept;

  <ins>template &lt;class T, class ...Args&gt;
    constexpr array_t&lt;common_type_t&lt;T, Args...&gt;, 1 + sizeof...(Args)&gt;
    make_array(const T&amp;, const Args&amp;...);</ins>
}</pre>
</blockquote>

<p>Modify section 23.3.2.1 [array.overview]:</p>

<blockquote>
  <p><strong>-1-</strong> The header <code>&lt;array&gt;</code> defines a class
  template for storing fixed-size sequences of objects. An array supports
  random access iterators. An instance of <code>array&lt;T, N&gt;</code> stores
  <code>N</code> elements of type <code>T</code>, so that <code>size() ==
  N</code> is an invariant. The elements of an array are stored contiguously,
  meaning that if <code>a</code> is an <code>array&lt;T, N&gt;</code> then it
  obeys the identity <code>&amp;a[n] == &amp;a[0] + n</code> for all <code>0
  &lt;= n &lt; N</code>.</p>

  <p><strong>-2-</strong> An <code>array</code> is an aggregate (8.5.1) that
  can be initialized with the syntax<br>
  <code>array&lt;T, N&gt; a = { <em>initializer-list</em> };</code><br>
  where <em>initializer-list</em> is a comma-separated list of up to
  <code>N</code> elements whose types are convertible to <code>T</code>.</p>

  <p><strong>-3-</strong> An <code>array</code> satisfies all of the
  requirements of a container and of a reversible container (23.2), except that
  a default constructed <code>array</code> object is not empty and that
  <code>swap</code> does not have constant complexity. An <code>array</code>
  satisfies some of the requirements of a sequence container (23.2.3).
  Descriptions are provided here only for operations on <code>array</code> that
  are not described in one of these tables and for operations where there is
  additional semantic information.</p>
  <pre>namespace std {
  template &lt;class T, size_t N &gt;
  struct array {
    <i>// types:</i>
    typedef T&amp;                                reference;
    typedef const T&amp;                          const_reference;
    typedef <i>implementation-defined</i>            iterator;
    typedef <i>implementation-defined</i>            const_iterator;
    typedef size_t                            size_type;
    typedef ptrdiff_t                         difference_type;
    typedef T                                 value_type;
    typedef T*                                pointer;
    typedef const T*                          const_pointer;
    typedef reverse_iterator&lt;iterator&gt;        reverse_iterator;
    typedef reverse_iterator&lt;const_iterator&gt;  const_reverse_iterator;

    T       elems[N];  <i>// exposition only</i>

    <i>// no explicit construct/copy/destroy for aggregate type</i>

    void fill(const T&amp; u);
    void swap(array&amp;) noexcept(noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;())));

    <i>// iterators:</i>
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;

    reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <i>// capacity:</i>
    constexpr size_type size() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr bool empty() const noexcept;

    <i>// element access:</i>
    reference operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    reference at(size_type n);
    constexpr const_reference at(size_type n) const;
    reference front();
    constexpr const_reference front() const;
    reference back();
    constexpr const_reference back() const;

    T * data() noexcept;
    const T * data() const noexcept;
  };
}</pre>

  <p><strong>-4-</strong> [ <em>Note:</em> The member variable
  <code>elems</code> is shown for exposition only, to emphasize that
  <code>array</code> is a class aggregate. The name <code>elems</code> is not
  part of <code>array</code>&rsquo;s interface. <em>&mdash;end note</em> ]</p>
</blockquote>

<p>Modify section 23.3.2.2 [array.cons]</p>

<blockquote>
  <p><strong>-1-</strong> The conditions for an aggregate (8.5.1) shall be met.
  Class <code>array</code> relies on the implicitly-declared special member
  functions (12.1, 12.4, and 12.8) to conform to the container requirements
  table in 23.2. In addition to the requirements specified in the container
  requirements table, the implicit move constructor and move assignment
  operator for <code>array</code> require that <code>T</code> be
  <code>MoveConstructible</code> or <code>MoveAssignable</code>,
  respectively.</p>
</blockquote>

<p>Modify section 23.3.2.3 [array.special]</p>

<blockquote>
  <pre>template &lt;class T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x, array&lt;T,N&gt;&amp; y) noexcept(noexcept(x.swap(y)));</pre>

  <p><strong>-1-</strong> <em>Effects:</em><br>
  <code>x.swap(y);</code></p>

  <p><strong>-2-</strong> <em>Complexity:</em> linear in <code>N</code>.</p>
</blockquote>

<p>Modify section 23.3.2.4 [array.size]</p>

<blockquote>
  <pre>template &lt;class T, size_t N&gt; constexpr size_type array&lt;T,N&gt;::size() const noexcept;</pre>

  <p><strong>-1-</strong> <em>Returns:</em> <code>N</code></p>
</blockquote>

<p>Modify section 23.3.2.5 [array.data]</p>

<blockquote>
  <pre>T *data() noexcept;</pre>
  <pre>const T *data() const noexcept;</pre>

  <p><strong>-1-</strong> <em>Returns:</em> <code>elems</code>.</p>
</blockquote>

<p>Modify section 23.3.2.6 [array.fill]</p>

<blockquote>
  <pre>void fill(const T&amp; u);</pre>

  <p><strong>-1-</strong> <em>Effects:</em> <code>fill_n(begin(), N,
  u)</code></p>
</blockquote>

<p>Modify section 23.3.2.7 [array.swap]</p>

<blockquote>
  <pre>void swap(array&amp; y) noexcept(noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;())));</pre>

  <p><strong>-1-</strong> <em>Effects:</em> <code>swap_ranges(begin(), end(),
  y.begin())</code></p>

  <p><strong>-2-</strong> <em>Throws:</em> Nothing unless one of the
  element-wise swap calls throws an exception.</p>

  <p><strong>-3-</strong> <em>Note:</em> Unlike the <code>swap</code> function
  for other containers, <code>array::swap</code> takes linear time, may exit
  via an exception, and does not cause iterators to become associated with the
  other container.</p>
</blockquote>

<p>Modify section 23.3.2.8 [array.zero]</p>

<blockquote>
  <p><strong>-1-</strong> <code>array</code> shall provide support for the
  special case <code>N == 0</code>.</p>

  <p><strong>-2-</strong> In the case that <code>N == 0</code>, <code>begin()
  == end() ==</code> unique value. The return value of <code>data()</code> is
  unspecified.</p>

  <p><strong>-3-</strong> The effect of calling <code>front()</code> or
  <code>back()</code> for a zero-sized array is undefined.</p>

  <p><strong>-4-</strong> Member function <code>swap()</code> shall have a
  <em>noexcept-specification</em> which is equivalent to
  <code>noexcept(true)</code>.</p>
</blockquote>

<p>Modify section 23.3.2.9 [array.tuple]</p>

<blockquote>
  <pre>tuple_size&lt;array&lt;T, N&gt; &gt;::value</pre>

  <p><strong>-1-</strong> <em>Return type:</em> integral constant
  expression.</p>

  <p><strong>-2-</strong> <em>Value:</em> <code>N</code></p>
  <pre>tuple_element&lt;I, array&lt;T, N&gt; &gt;::type</pre>

  <p><strong>-3-</strong> <em>Requires:</em> <code>I &lt; N</code>. The program
  is ill-formed if <code>I</code> is out of bounds.</p>

  <p><strong>-4-</strong> <em>Value:</em> The type <code>T</code>.</p>
  <pre>template &lt;size_t I, class T, size_t N&gt;
constexpr T&amp; get(array&lt;T, N&gt;&amp; a) noexcept;</pre>

  <p><strong>-5-</strong> <em>Requires:</em> <code>I &lt; N</code>. The program
  is ill-formed if <code>I</code> is out of bounds.</p>

  <p><strong>-6-</strong> <em>Returns:</em> A reference to the <code>I</code>th
  element of <code>a</code>, where indexing is zero-based.</p>
  <pre>template &lt;size_t I, class T, size_t N&gt;
constexpr T&amp;&amp; get(array&lt;T, N&gt;&amp;&amp; a) noexcept;</pre>

  <p><strong>-7-</strong> <em>Effects:</em> Equivalent to <code>return
  std::move(get&lt;I&gt;(a));</code></p>
  <pre>template &lt;size_t I, class T, size_t N&gt;
constexpr const T&amp; get(const array&lt;T, N&gt;&amp; a) noexcept;</pre>

  <p><strong>-8-</strong> <em>Requires:</em> <code>I &lt; N</code>. The program
  is ill-formed if <code>I</code> is out of bounds.</p>

  <p><strong>-9-</strong> <em>Returns:</em> A const reference to the
  <code>I</code>th element of <code>a</code>, where indexing is zero-based.</p>
</blockquote>

<h2 name="Ch07">VII. Acknowledgements</h2>

<h2 name="Ch08">VIII. References</h2>
<ul>
  <li>A Proposal to Add a Fixed Size Array Wrapper to the Standard Library,
    WG21 Document N15458=03-0131, 2003. <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1548.htm">www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1548.htm</a>
  </li>
  <li>Variadic Templates (Revision 3), WG21 Document N2080=06-0150, 2006. <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2080.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2080.pdf</a>
  </li>
</ul>
</body>
</html>
