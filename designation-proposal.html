<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=us-ascii">
  <title>Proposal to Add Designation to Initializers</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/">
  <style type="text/css">
  ins { background-color: #A0FFA0 }
  del { background-color: #FFA0A0 }
  </style>
</head>

<body>
<pre>Document number: Dnnnn
Project: Programming Language C++, Library Working Group
Date: 2013-11-15
Reply-to: Daryle Walker &lt;darylew at gmail dot com&gt;</pre>

<h1>Proposal to Add Designation to Initializers</h1>

<h2 id="Ch01">I. Table of Contents</h2>
<ol>
  <li><a href="#Ch01">Table of Contents</a></li>
  <li><a href="#Ch02">Introduction</a></li>
  <li><a href="#Ch03">Motivation and Scope</a></li>
  <li><a href="#Ch04">Impact on the Standard</a></li>
  <li><a href="#Ch05">Design Decisions</a></li>
  <li><a href="#Ch06">Technical Specifications</a></li>
  <li><a href="#Ch07">Acknowledgments</a></li>
  <li><a href="#Ch08">History</a></li>
  <li><a href="#Ch09">References</a></li>
</ol>

<h2 id="Ch02">II. Introduction</h2>

<p>As of the C++ 2014 drafts, initializer clauses in braced initialization
lists must be in the declared subobject order (not counting static data
members, unnamed bit fields, and skipped trailing subobjects). The 1999 edition
of the ISO C Standard adds the capability to override the order of subobject
initialization, including sub-subobjects. This proposal is to add this
capability to C++.</p>

<h2 id="Ch03">III. Motivation and Scope</h2>

<p>The motivation is to improve parity with C.</p>

<h2 id="Ch04">IV. Impact on the Standard</h2>

<p>The proposal adds to the initialization rules (section 8.5 [dcl.init]). At
least two implementations, Clang since version 2.8 and Microsoft's 2013 edition
of Visual Studio, incorporate this C99 feature into their C++11 compilers,
proving this proposal viable.</p>

<h2 id="Ch05">V. Design Decisions</h2>

<p>Specifying this feature should be as easy as importing the C Standard text
into the C++ Standard text, modulo how the two Standards differ in expressing
ideas. There are outstanding issues on how overriding initializations work when
said initializations are at the sub-subobject level; how are the unmentioned
sibling sub-subobjects initialized? (See forum post by Richard Smith.)</p>

<p>The elision rules ban subobjects of class types with multiple members,
therefore allowing class types of one member or array types. Thus this proposal
integrates N3526 by Michael Price. But I don't think I did it right; I think
N3526 allows a brace-levels between all or nothing, and this proposal
doesn't.</p>

<p>A post by Richard Smith suggested adding rules for how initializers are
sequenced.</p>

<h2 id="Ch06">VI. Technical Specifications</h2>

<p>The changes are based off C++ Working Draft Standard N3797. The numbers for
new paragraphs and footnotes have place-holders; the final numbers, plus moving
existing ID numbers to fit, are to be determined later.</p>

<p>In section 8.5 [dcl.init], modify the grammar production list after
paragraph 1:</p>

<blockquote>
  <dl>
    <dt><var>initializer:</var></dt>
      <dd><var>brace-or-equal-initializer</var></dd>
      <dd><code>(</code> <var>expression-list</var> <code>)</code></dd>
    <dt><var>brace-or-equal-initializer:</var></dt>
      <dd><code>=</code> <var>initializer-clause</var></dd>
      <dd><var>braced-init-list</var></dd>
    <dt><var>initializer-clause:</var></dt>
      <dd><var>assignment-expression</var></dd>
      <dd><var>braced-init-list</var></dd>
    <dt><ins><var>designated-initializer-clause:</var></ins></dt>
      <dd><ins><var>designator-list</var>
        <var>brace-or-equal-initializer</var></ins></dd>
    <dt><ins><var>designator-list:</var></ins></dt>
      <dd><ins><var>designator</var></ins></dd>
      <dd><ins><var>designator-list</var> <var>designator</var></ins></dd>
    <dt><ins><var>designator:</var></ins></dt>
      <dd><ins><code>[</code> <var>constant-expression</var>
        <code>]</code></ins></dd>
      <dd><ins><code>.</code> <code>template</code><sub><var>opt</var></sub>
        <var>id-expression</var></ins></dd>
    <dt><var>initializer-list:</var></dt>
      <dd><var>initializer-clause</var>
        <code>...</code><sub><var>opt</var></sub></dd>
      <dd><ins><var>designated-initializer-clause</var>
        <code>...</code><sub><var>opt</var></sub></ins></dd>
      <dd><var>initializer-list</var> <code>,</code>
        <var>initializer-clause</var>
      <code>...</code><sub><var>opt</var></sub></dd>
      <dd><ins><var>initializer-list</var> <code>,</code>
        <var>designated-initializer-clause</var>
        <code>...</code><sub><var>opt</var></sub></ins></dd>
    <dt><var>braced-init-list:</var></dt>
      <dd><code>{</code> <var>initializer-list</var>
        <code>,</code><sub><var>opt</var></sub> <code>}</code></dd>
      <dd><code>{</code> <code>}</code></dd>
  </dl>
</blockquote>

<p>Add these changes to the last part of section A.7 [gram.decl]. And add the
terms <var>designated-initializer-clause</var>, <var>designator-list</var>, and
<var>designator</var> to the Index of grammar productions.</p>

<p><u>Author's Note:</u> I don't know if appropriate members can ever be
described that require the <code>template</code> keyword preceding them.</p>

<p>In the same section (8.5), add new paragraphs before paragraph 2:</p>

<blockquote>
  <p><strong>-A-</strong> A <dfn>designator</dfn> is a token sequence
  representing a single element or member access from an unwritten reference to
  an object. When the implementation needs to synthesize
  <var>designator</var>s, any required numeric values are canonically
  represented by an integer-literal. A <var>designator-list</var> is a chain of
  designators. The (possibly) nested subobject accessed from an unwritten
  object through a <var>designator-list</var> is the list's <dfn>target
  object</dfn>.</p>

  <p><strong>-B-</strong> A <var>designated-initializer-clause</var> (or pack
  expansion thereof) shall be permitted as a term of an
  <var>initializer-list</var> only when the immediately-enclosing
  <var>braced-init-list</var> corresponds to a object that is under aggregate
  initialization (8.5.1).</p>
</blockquote>

<p>In section 8.5.1 [dcl.init.aggr], add several new paragraphs before
paragraph 2:</p>

<blockquote>
  <p><strong>-A-</strong> An aggregate type's <dfn>first-order initialization
  list</dfn> is:</p>
  <ul>
    <li>For an array type, its (direct) elements, in increasing subscript
      order. For an array of unknown bound, the maximum subscript approaches
      infinity.</li>
    <li>For a class type, its non-static data members, in declaration order,
      but excluding anonymous bit-fields, and replacing non-static members of
      anonymous class type with the member's own first-order initialization
      list. [<em>Note:</em> A list may end up empty for class types.
      <em>&mdash;end note</em>]</li>
  </ul>

  <p>If all the entries of a first-order initialization list have aggregate
  types themselves, then the aggregate type's second-order initialization list
  is formed by replacing each entry of the previous-order initialization list
  with their own first-order initialization lists. This process can be repeated
  until a given nth-order initialization list has at least one non-aggregate
  entry. That last list is of the aggregate type's <dfn>maximum initialization
  list order</dfn>. [<em>Note:</em> Nth-order initialization lists are ordered
  lists. <em>&mdash;end note</em>]</p>

  <p><strong>-B-</strong> For a given <var>assignment-expression</var>
  <var>Y</var> and aggregate type, their elision order <var>N</var> is the
  lowest value where the first entry of the aggregate type's
  <var>N</var>th-order initialization list can be copy-initialized by
  <var>Y</var> and be well-formed. If the maximum-order initialization list is
  reached and usage of <var>Y</var> would still be ill-formed, or if any
  transition between orders involves expanding a class type with a first-order
  initialization list that is not exactly one in length, then the elision order
  shall be one.</p>

  <p><strong>-C-</strong> An entry in an aggregate type's nth-order
  initialization list can have a <dfn>designated-follower</dfn>, which is
  another entry of the list. If the entry is not a direct subobject of a union,
  its designated-follower is its immediate successor. Otherwise its
  designated-follower is the first succeeding entry whose subobject is not part
  of any of the current entry's subobject's immediately-enclosing unions. If
  the end of the list is reached before identifying a qualified successor, then
  the entry has no designated-follower. [<em>Note:</em> The list has no end if
  the aggregate type is an array of unknown bound. <em>&mdash;end note</em>]</p>

  <p><strong>-D-</strong> An <var>initializer-clause</var> can be converted to
  a <var>designated-initializer-clause</var> by first preceding it with a
  <code>=</code> token, then preceding that with the <var>designator-list</var>
  for the target object from the aggregate. [<em>Note:</em> As
  <var>initializer-clause</var>s always use copy-initialization, so do their
  corresponding <var>designated-initializer-clause</var>s. <em>&mdash;end
  note</em>] An clause of either kind has a <dfn>virtual designator list</dfn>,
  which is either a <var>designated-initializer-clause</var>'s actual
  designator-list, or the one an <var>initializer-clause</var> would have after
  conversion to a <var>designated-initializer-clause</var>.</p>

  <p><strong>-E-</strong> Given an aggregate type, its initialization list of
  order <var>N</var> and an <var>initializer-clause</var>: if the clause
  appears as the first initializer for an aggregate initialization of the given
  type, then the clause's target object shall be the initialization list's
  first entry's corresponding subobject, else it shall be the corresponding
  subobject of the designated-follower of the entry whose corresponding
  subobject has a virtual designator list of the first <var>N</var> designators
  of the previous initializer's virtual designator list. [<em>Note:</em> In a
  <var>N</var>th-order initialization list, every entry's subobject has a
  virtual designator list of length <var>N</var>, so each initializer's virtual
  designator list must have at least <var>N</var> designators. <em>&mdash;end
  note</em>] [<em>Note:</em> If the <var>initializer-clause</var> is an
  <var>assignment-expression</var>, <var>N</var> must equal the elision order
  between the clause and aggregate type. <em>&mdash;end note</em>]</p>
</blockquote>

<p>Then modify paragraph 2:</p>

<blockquote>
  <p><strong>-2-</strong> When an aggregate is initialized by an initializer
  list, as specified in 8.5.4, the elements of the initializer list are taken
  as initializers for <del>the members</del> <ins>subobjects</ins> of the
  aggregate, in <del>increasing subscript or member</del> order <ins>of the
  aggregate type's <var>N</var>th-order initialization list (modulo jumps
  caused by <var>designated-initialization-clause</var>s), where <dfn>N</dfn>
  is the elision order of the aggregate type and the first initializer if said
  initializer is an <var>assignment-expression</var>, and one otherwise</ins>.
  <del>Each member is copy-initialized from the corresponding
  <var>initializer-clause</var>.</del> <ins>Each mentioned subobject is either
  copy-initialized from a single corresponding <var>initializer-clause</var>,
  initialized from the post-<var>designator-list</var> part of a single
  corresponding <var>designated-initializer-clause</var> (which may use either
  copy- or direct-initialization), or initialized in composite if several
  initializers apply to a subobject (in whole or part).</ins> If <del>the</del>
  <ins>either an</ins> <var>initializer-clause</var> <ins>or the
  post-<var>designator-list</var> part of a
  <var>designator-initializer-clause</var></ins> is an expression and a
  narrowing conversion (8.5.4) is required to convert the expression, the
  program is ill-formed. [<em>Note:</em> If <ins>either</ins> an
  <var>initializer-clause</var> <ins>or the post-<var>designator-list</var>
  part of a <var>designator-initializer-clause</var></ins> is itself an
  initializer list, the <del>member</del> <ins>target object</ins> is
  list-initialized, which will result in a recursive application of the rules
  in this section if the <del>member</del> <ins>target object</ins> is an
  aggregate. <em>&mdash;end note</em>] [<em>Example:</em></p>
  <pre>struct A {
  int x;
  struct B {
    int i;
    int j;
  } b;
} a = { 1, { 2, 3 } };</pre>

  <p>initializes <code>a.x</code> with 1, <code>a.b.i</code> with 2,
  <code>a.b.j</code> with 3. <em>&mdash;end example</em>]</p>
</blockquote>

<p>Then modify paragraph 4:</p>

<blockquote>
  <p><strong>-4-</strong> An array of unknown <del>size</del> <ins>bound</ins>
  initialized with a <del>brace-enclosed <var>initializer-list</var></del>
  <ins><var>braced-init-list</var></ins> containing <del><code>n</code>
  <var>initializer-clauses</var>, where <code>n</code> shall be greater than
  zero,</del> <ins>a positive number of initializers</ins> is defined as having
  <var>n</var> elements (8.3.4)<ins>, where <dfn>n</dfn> is one greater than
  the maximum value among the initializers' virtual designator list's first
  designator's subscripts</ins>. [<em>Example:</em></p>
  <pre>int x[] = { 1, 3, 5 };</pre>

  <p>declares and initializes <var>x</var> as a one-dimensional array that has
  three elements since no size was specified and there are three initializers.
  <em>&mdash;end example</em>] <ins>[<em>Example:</em></ins></p>
  <pre><ins>int y[][2] = { 2, 4, 6, 8, 10 };</ins></pre>

  <p><ins>declares and initializes <var>y</var> as a two-dimensional array of
  three elements, each an array of two elements. With an elision order of 2,
  each pair of loose inner elements was grouped as an array of the outer
  element. The second element of the third outer array gets initialized with an
  empty list (i.e. zero). Since there are no <var>designator</var>s used, the
  last element's virtual designator list, <code>[2][0]</code>, also reveals the
  answer. <em>&mdash;end example</em>] [<em>Example:</em></ins></p>
  <pre><ins>int z[] = { 100, [3] = 101, 102, [1] = 103 };</ins></pre>

  <p><ins>declares and initializes <var>z</var> as a one-dimensional array. All
  the initializers have a single element virtual designator list. Among the
  subscripts of the first designators of said lists, the maximum subscript is 4
  (for the element of value 102 and virtual designator list <code>[4]</code>).
  So <var>z</var> is assigned an element length of 5. (The element with virtual
  designator list <code>[2]</code> is initialized with an empty list.)
  <em>&mdash;end example</em>]</ins> An empty initializer list <code>{}</code>
  shall not be used as the <var>initializer-clause</var> for an array of
  unknown bound<sup>107</sup>.</p>
</blockquote>

<p>(Footnote 107 is unchanged.)</p>

<p>Paragraph 5 should be removed. (<u>Author's Note:</u> Its main information
is now in paragraph A.)</p>

<p>Modify paragraph 6:</p>

<blockquote>
  <p><strong>-6-</strong> An <var>initializer-list</var><ins>, using an
  initialization list of order <var>N</var>,</ins> is ill-formed if the
  <del>number</del> <ins>virtual designator list</ins> of <ins>an</ins>
  <var>initializer-clause</var><del>s</del> <ins>or
  <var>designated-initializer-clause</var></ins> <del>exceeds the number of
  members or elements to initialize</del> <ins>has a <var>designator</var> that
  would reference: a static data member, a member within a non-aggregate, a
  non-existent member, an excessive subscript, an element as a subobject of
  class type, a member as a subobject of array type, or anything that would go
  beyond the last entry of the aggregate type's <var>N</var>th-order
  initialization list</ins>. [<em>Example:</em></p>
  <pre>char cv[4] = { &rsquo;a&rsquo;, &rsquo;s&rsquo;, &rsquo;d&rsquo;, &rsquo;f&rsquo;, 0 }; <i>// error</i></pre>

  <p>is ill-formed. <em>&mdash;end example</em>] <ins>[<em>Note:</em> A pack
  expansion of an <var>initializer-clause</var> or
  <var>designated-initializer-clause</var> may create instantiations that
  result in an ill-formed <var>initializer-list</var>. <em>&mdash;end
  note</em>] If a <var>designated-initializer-clause</var> uses a
  <var>designator-list</var> of a length shorter than the order of the
  initialization list, the <var>initializer-list</var> is ill-formed.
  [<em>Example:</em></ins></p>
  <pre><ins>char sl[][2] = { 'h', 'j', [1] = {[0]{'k'}, 'l'}, [2][1]{'\''}, [2][0] = ';' }; <i>// error</i></ins></pre>

  <p><ins>is ill-formed due to the third initializer. <em>&mdash;end
  example</em>]</ins></p>
</blockquote>

<p>Add several paragraphs after paragraph 6:</p>

<blockquote>
  <p><strong>-F-</strong> When an aggregate initialization for a non-union type
  is evaluated, the direct subobjects are initialized in order; an array type's
  initialization starts from the first element and proceeds in increasing
  subscript order while a class type's initialization starts from the first
  declared non-static data member and proceeds in succeeding declaration order,
  including anonymous bit-fields and class types, but excluding static data
  members. Evaluation occurs after pack expansions (14.5.3) for applicable
  <var>initializer-clause</var>s and <var>designated-initializer-clause</var>s
  have been resolved. [<em>Note:</em> Arrays of unknown bound have their bound
  fixed before evaluation, based on the (post-pack-expanded) initializers'
  virtual designator lists, as described earlier. <em>&mdash;end note</em>]
  Every value computation and side effect associated with a given direct
  subobject's initialization is sequenced before every value and computation
  and side effect associated with initializations of later direct subobjects.
  [<em>Note:</em> This evaluation ordering holds regardless of the semantics of
  the aggregate initialization. <em>&mdash;end note</em>]</p>

  <p><strong>-G-</strong> Each initializer shall be matched with the direct
  subobject that is or contains that initializer's target object. If a direct
  subobject has no initializers that match with it, then its initialization
  shall be evaluated with its <var>brace-or-equal-initializer</var> or, if
  there is no <var>brace-or-equal-initializer</var>, an empty initializer list
  (8.5.4). If a direct subobject's lexically last matching initializer
  references the object in whole and does not use aggregate initialization,
  then its initialization shall be evaluated with said initializer.
  [<em>Note:</em> If the initializer is an <var>initializer-clause</var>, then
  copy-initialization is performed, else the type of initialization denoted by
  the post-<var>designator-list</var> part of the
  <var>designated-initializer-clause</var> is performed. <em>&mdash;end
  note</em>] [<em>Note:</em> An initializer matching a member of anonymous
  class type always references it in part. <em>&mdash;end note</em>] Otherwise,
  the direct subobject shall be evaluated with aggregate initialization; the
  subaggregate is a composite of all matching initializers except the ones
  before and at the lexically last matching initializer that references the
  object in whole and does not use aggregate initialization. To build its
  composite subaggregate: matching initializers from
  <var>initializer-clause</var>s are converted to
  <var>designated-initializer-clause</var>s; matching subaggregate initializers
  have their root-level <var>initializer-clause</var>s converted to
  <var>designated-initializer-clause</var>s (relative to the subaggregate)
  [<em>Note:</em> The internals of sub-subaggregates are not altered.
  <em>&mdash;end note</em>]; insertions to the composite occur in lexical
  order, with aggregate-level clauses inserted with their first
  <var>designator</var> removed, and the initializers within subaggregate-level
  clauses inserted directly.</p>

  <p><strong>-H-</strong> When an aggregate initialization for a union-type is
  evaluated, and the same variant member is or contains every initializer's
  target object, then the variant member shall be the active member of its
  enclosing union (Which is either the aggregate directly or an anonymous
  union; if the latter, said anonymous union is the active member of the
  aggregate.) and its initialization shall be evaluated with a subaggregate
  identical to the original aggregate except that any root-level
  <var>designated-initializer-clause</var>s lose their first designator.
  [<em>Note:</em> If there is an <var>initializer-clause</var> in the
  aggregate, it must be the only one, it must be the first one, and any
  trailing <var>designated-initializer-clause</var> must target the union's
  first variant member in whole or part. <em>&mdash;end note</em>] Targeting
  across multiple variant members is conditionally supported with
  implementation-defined semantics; initializations of any trivial union type
  shall be supported. When there are no initializers: if a variant member has a
  <var>brace-or-equal-initializer</var>, then that variant member shall be the
  active member of its immediately enclosing union and its initialization shall
  be evaluated with its <var>brace-or-equal-initializer</var>, else the first
  variant member shall be the active member of its immediately enclosing union
  and its initialization shall be evaluated with an empty initializer list; if
  the aggregate isn't the variant member's immediate encloser, then the
  intermediate anonymous union is the active member of the aggregate.</p>
</blockquote>

<p>Paragraph 7 should be removed. (<u>Author's Note:</u> Its main information
is now in paragraphs G and H.)</p>

<p><u>Author's Query</u>: Should paragraph 8 be removed? Its material is
sort-of implied from paragraphs C and G. Maybe it needs to be reworked
instead?</p>

<p>Paragraphs 10 and 11 should be removed. (<u>Author's Note:</u> Their main
information is now in paragraphs A, B, and C.)</p>

<p>Modify paragraph 12:</p>

<blockquote>
  <p><strong>-12-</strong> All implicit type conversions (Clause 4) are
  considered when initializing <del>the</del> <ins>an</ins> aggregate member
  with an <var>assignment-expression</var>. <ins>[<em>Note:</em> This applies
  to <var>initializer-clause</var>s and
  <var>designated-initializer-clause</var>s that do not use a (top-level)
  <var>braced-init-list</var>. <em>&mdash;end note</em>]</ins> If the
  <var>assignment-expression</var> can initialize a member, the member is
  initialized. Otherwise, if the member is itself a subaggregate, <del>brace
  elision</del> <ins>a context of an initialization list of the elision order
  between the <var>assignment-expression</var> and the subaggregate type</ins>
  is assumed and the <var>assignment-expression</var> is considered for the
  initialization of the first member of the subaggregate. [<em>Note:</em>
  <del>As specified above, brace elision cannot apply to subaggregates with no
  members for purposes of aggregate initialization;</del> <ins>When a
  subaggregate type has an empty first-order initialization list,</ins> an
  <var>initializer-clause</var> <ins>or
  <var>designated-initializer-clause</var></ins> for the entire subobject is
  required. <em>&mdash;end note</em>][<em>Example:</em></p>
  <pre>struct A {
  int i;
  operator int();
};
struct B {
  A a1, a2;
  int z;
};

A a;
B b = { 4, a, a };</pre>

  <p><del>Braces are elided around</del> <ins>An elision context applies
  on</ins> the <var>initializer-clause</var> for <code>b.a1.i</code>.
  <code>b.a1.i</code> is initialized with 4, <code>b.a2</code> is initialized
  with <code>a</code>, <code>b.z</code> is initialized with whatever
  <code>a.operator int()</code> returns. <em>&mdash;end example</em>]</p>
</blockquote>

<p>Paragraphs 15 should be removed. (<u>Author's Note:</u> Its information is
covered by paragraphs A, C, and E.)</p>

<p>Paragraph 16 should be removed. (<u>Author's Note:</u> Its main information
is covered by paragraph 12 plus what was needed by paragraph 15.)</p>

<p><u>Author's Query:</u> Can anyone provide examples that cover the (possibly)
removed paragraphs (5, 7, 10, 11, 15, 16)? They should at least cover the
material the examples within those paragraphs did.</p>

<p>In section 8.5.4 [dcl.init.list], modify paragraph 4:</p>

<blockquote>
  <p><strong>-4-</strong> Within the <var>initializer-list</var> of a
  <var>braced-init-list</var> <ins>that has no
  <var>designated-initializer-clause</var>s</ins>, the
  <var>initializer-clauses</var>, including any that result from pack
  expansions (14.5.3), are evaluated in the order in which they appear. That
  is, every value computation and side effect associated with a given
  <var>initializer-clause</var> is sequenced before every value computation and
  side effect associated with any <var>initializer-clause</var> that follows it
  in the comma-separated list of the <var>initializer-list</var>.
  [<em>Note:</em> This evaluation ordering holds regardless of the semantics of
  the initialization; for example, it applies when the elements of the
  <var>initializer-list</var> are interpreted as arguments of a constructor
  call, even though ordinarily there are no sequencing constraints on the
  arguments of a call. <em>&mdash;end note</em>] <ins>[<em>Note:</em> If the
  <var>initializer-list</var> contains
  <var>designated-initializer-clause</var>s, the <var>braced-init-list</var>
  must be for aggregate initialization (8.5.1). <em>&mdash;end
  note</em>]</ins></p>
</blockquote>

<p>In section 14.5.3 [temp.variadic], modify the third list item (not counting
the second item's inner list) of paragraph 4:</p>

<blockquote>
  <ul>
    <li>In an <var>initializer-list</var> (8.5); the pattern is
      <ins>either</ins> an <var>initializer-clause</var> <ins>or
      <var>designated-initializer-clause</var></ins>.</li>
  </ul>
</blockquote>

<h2 id="Ch07">VII. Acknowledgments</h2>

<h2 id="Ch08">VIII. History</h2>

<h2 id="Ch09">IX. References</h2>
<ul>
  <li>"<a
    href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/WT5_DLp5Stg/wc1mj8DxIfMJ">Designated
    initializers (like C99)</a>" post by Richard Smith on 28 Oct 2013 (Monday)
    at 11:15:54.</li>
  <li>Uniform initialization for arrays and class aggregate types, WG21
    Document N3526, 2013. <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3526.html">www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3526.html</a>
  </li>
  <li>"<a
    href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/IgDFqKjKlRs/CGARpDJy9JsJ">Proposal
    to add C99 designated initializers to C++</a>" post by Richard Smith on 10
    Nov 2013 (Sunday) at 18:42:14.</li>
</ul>
</body>
</html>
